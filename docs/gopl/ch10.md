### **Chapter 10. Packages and the Go Tool**

In a program, the majority of the functions were written by others and made available for reuse through **packages**.

Go has over 100 standard packages that provide the foundations for most applications.  The Go community has published many more, and you can find a searchable index of them at [https://godoc.org](https://godoc.org/). This chapter discusses how to use existing packages and create new ones.

Go also comes with the `go` tool, a sophisticated but simple-to-use command for managing workspaces of Go packages. Since the beginning of the book, weâ€™ve been showing how to use the `go` tool to download, build, and run example programs. This chapter studies the tools' underlying concepts and its capabilities, which include printing documentation and querying metadata about the packages in the workspace.

### Introduction

The purpose of any package system is to make the design and maintenance of large programs practical by grouping related features together into units that can be easily understood and changed, independent of the other packages of the program.

This [*modularity*](https://en.wikipedia.org/wiki/Modular_programming) allows packages to be:

* Shared and reused by different projects,
* Distributed within an organization, or,
* Made available to the wider world.

Each package defines a distinct name space that encloses its identifiers. Each name is associated with a particular package, so we can choose short, clear names for the types, functions, etc. that we use most often, without creating conflicts with other parts of the program.

Packages also provide [*encapsulation*](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)) by controlling which names are visible or exported outside the package. Restricting the visibility of package members has two advantages:

* It hides the helper functions and types behind the package's API, allowing the package maintainer to change the implementation without affecting code outside the package.
* It hides variables so that clients can access and update them only through exported functions that preserve internal invariants or enforce mutual exclusion in a concurrent program.

When we change a file, we must recompile the file's package and potentially all the packages that depend on it. Go compilation is notably faster than most other compiled languages, even when building from scratch. There are three main reasons for the compiler's speed.

1. All imports must be explicitly listed at the beginning of each source file, so the compiler does not have to read and process an entire file to determine its dependencies.
2. The dependencies of a package form a directed acyclic graph, and because there are no cycles, packages can
be compiled separately and perhaps in parallel.
3. The object file for a compiled Go package records export information not just for the package itself, but also for its dependencies. When compiling a package, the compiler must read one object file for each import but need
not look beyond these files.

### Import Paths

Each package is identified by a unique string called its [*import path*](https://golang.org/doc/code.html#ImportPaths). Import paths are the strings that appear in `import` declarations.

```go
import (
	"fmt"
	"math/rand"
	"encoding/json"
	"golang.org/x/net/html"
	"github.com/go-sql-driver/mysql"
)
```

As mentioned in [Section 2.6.1](ch2.md#imports), the Go language specification doesn't define the meaning of these strings or how to determine a packages' import path, but leaves these issues to the tools.  This chapter discusses how the `go` tool interprets them, which is what the majority of Go programmers use for building, testing, and so on. However, other tools do exist. For example, Go programmers using Google's internal multi-language build system follow different rules for naming and locating packages, specifying tests, and so on, that more closely match the conventions of that system.

For packages you intend to share or publish, import paths should be globally unique. To avoid conflicts, the import paths of all packages other than those from the standard library should start with the Internet domain name of the organization that owns or hosts the package; this also makes it possible to find packages.
